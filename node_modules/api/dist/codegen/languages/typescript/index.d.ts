import type { InstallerOptions } from '../../factory.js';
import type Oas from 'oas';
import type { ClassDeclaration, SourceFile } from 'ts-morph';
import { Project } from 'ts-morph';
import Storage from '../../../storage.js';
import CodeGenerator from '../../codegenerator.js';
export default class TSGenerator extends CodeGenerator {
    #private;
    project: Project;
    types: Map<string, string>;
    sdk: ClassDeclaration;
    schemas: Record<string, {
        body?: unknown;
        metadata?: unknown;
        response?: Record<string, unknown>;
    } | Record<string, unknown>>;
    usesHTTPMethodRangeInterface: boolean;
    constructor(spec: Oas, specPath: string, identifier: string);
    install(storage: Storage, opts?: InstallerOptions): Promise<void>;
    static uninstall(storage: Storage, opts?: InstallerOptions): Promise<void>;
    /**
     * Compile the TS code we generated into JS for use in CJS and ESM environments.
     *
     */
    compile(storage: Storage, opts?: InstallerOptions): Promise<void>;
    /**
     * Generate the current OpenAPI definition into a TypeScript library.
     *
     */
    generate(): Promise<{
        [x: string]: string;
    }>;
    getExampleCodeSnippet(): Promise<string | false>;
    /**
     * Create our main SDK source file.
     *
     */
    private createSDKSource;
    /**
     * Create an IIFE export of our SDK in the SDK source file so users can do
     * `import sdk from '<package>'` and have a ready-to-go instance of their SDK -- eliminating them
     * having to create an instance with `new SDK()`.
     *
     * This will also fill our a JSDoc heading on the IIFE we're creating based on various pieces of
     * data that may be present in the OpenAPI definition `info` object.
     *
     * Additionally if a license in `info.license` is recognized by the SPDX we'll also create a
     * `LICENSE` file in for their generated SDK. We're only supporting SPDX-recognized licenses for
     * this because we otherwise have no idea what the license represents and we should be extremely
     * cautious around assuming intent with software licensing.
     *
     * @see {@link https://spdx.org/licenses/}
     */
    createSDKExport(sourceFile: SourceFile): SourceFile;
    /**
     * Creates a `.gitignore` file to prevent the `dist/` directory from being tracked.
     *
     */
    createGitIgnore(): SourceFile;
    /**
     * Create the `tsconfig.json` file that will allow this SDK to be compiled for use.
     *
     */
    createTSConfig(): SourceFile;
    /**
     * Create the `package.json` file that will ultimately make this SDK available to use.
     *
     */
    createPackageJSON(): SourceFile;
    /**
     * Create a placeholder `README.md` file in the repository, with information on how to use/administer the SDK.
     *
     */
    createREADME(): Promise<SourceFile>;
    /**
     * Create our main schemas file. This is where all of the JSON Schema that our TypeScript typing
     * infrastructure sources its data from. Without this there are no types.
     *
     */
    private createSchemasFile;
    /**
     * Create our main types file. This sources its data from the JSON Schema `schemas.ts` file and
     * will re-export types to be used in TypeScript implementations and IDE intellisense. This
     * typing work is functional with the `json-schema-to-ts` library.
     *
     * @see {@link https://npm.im/json-schema-to-ts}
     */
    private createTypesFile;
    /**
     * Create operation accessors on the SDK.
     *
     */
    private createOperationAccessor;
    /**
     * Scour through the current OpenAPI definition and compile a store of every operation, along
     * with every HTTP method that's in use, and their available TypeScript types that we can use,
     * along with every HTTP method that's in use.
     *
     */
    private loadOperationsAndMethods;
    /**
     * Compile the parameter (path, query, cookie, and header) schemas for an API operation into
     * usable TypeScript types.
     *
     */
    private prepareParameterTypesForOperation;
    /**
     * Compile the response schemas for an API operation into usable TypeScript types.
     *
     */
    private prepareResponseTypesForOperation;
    /**
     * Add a given schema into our schema dataset that we'll be be exporting as types.
     *
     */
    private addSchemaToExport;
}
//# sourceMappingURL=index.d.ts.map