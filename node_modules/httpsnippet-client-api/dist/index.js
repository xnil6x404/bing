// src/index.ts
import { CodeBuilder } from "@readme/httpsnippet/helpers/code-builder";

// node_modules/camelcase/index.js
var UPPERCASE = /[\p{Lu}]/u;
var LOWERCASE = /[\p{Ll}]/u;
var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
var SEPARATORS = /[_.\- ]+/;
var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
var preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase2) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  let isLastLastCharPreserved = false;
  for (let index = 0; index < string.length; index++) {
    const character = string[index];
    isLastLastCharPreserved = index > 2 ? string[index - 3] === "-" : true;
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = string.slice(0, index) + "-" + string.slice(index);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      index++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase2)) {
      string = string.slice(0, index - 1) + "-" + string.slice(index - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
    }
  }
  return string;
};
var preserveConsecutiveUppercase = (input, toLowerCase) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replaceAll(LEADING_CAPITAL, (match) => toLowerCase(match));
};
var postProcess = (input, toUpperCase) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ["_", "-"].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match)).replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier));
};
function camelCase(input, options) {
  if (!(typeof input === "string" || Array.isArray(input))) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options = {
    pascalCase: false,
    preserveConsecutiveUppercase: false,
    ...options
  };
  if (Array.isArray(input)) {
    input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
  } else {
    input = input.trim();
  }
  if (input.length === 0) {
    return "";
  }
  const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
  const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
  if (input.length === 1) {
    if (SEPARATORS.test(input)) {
      return "";
    }
    return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
  }
  const hasUpperCase = input !== toLowerCase(input);
  if (hasUpperCase) {
    input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
  if (options.pascalCase) {
    input = toUpperCase(input.charAt(0)) + input.slice(1);
  }
  return postProcess(input, toUpperCase);
}

// src/index.ts
import contentType from "content-type";
import Oas from "oas";
import { matchesMimeType } from "oas/utils";
import { isReservedOrBuiltinsLC } from "reserved2";

// node_modules/is-regexp/index.js
var { toString } = Object.prototype;
function isRegexp(value) {
  return toString.call(value) === "[object RegExp]";
}

// node_modules/is-obj/index.js
function isObject(value) {
  const type = typeof value;
  return value !== null && (type === "object" || type === "function");
}

// ../../node_modules/get-own-enumerable-keys/index.js
var { propertyIsEnumerable } = Object.prototype;
function getOwnEnumerableKeys(object) {
  return [
    ...Object.keys(object),
    ...Object.getOwnPropertySymbols(object).filter((key) => propertyIsEnumerable.call(object, key))
  ];
}

// node_modules/stringify-object/index.js
function stringifyObject(input, options, pad) {
  const seen = [];
  return function stringify2(input2, options2 = {}, pad2 = "") {
    const indent = options2.indent || "	";
    let tokens;
    if (options2.inlineCharacterLimit === void 0) {
      tokens = {
        newline: "\n",
        newlineOrSpace: "\n",
        pad: pad2,
        indent: pad2 + indent
      };
    } else {
      tokens = {
        newline: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
        newlineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
        pad: "@@__STRINGIFY_OBJECT_PAD__@@",
        indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
      };
    }
    const expandWhiteSpace = (string) => {
      if (options2.inlineCharacterLimit === void 0) {
        return string;
      }
      const oneLined = string.replace(new RegExp(tokens.newline, "g"), "").replace(new RegExp(tokens.newlineOrSpace, "g"), " ").replace(new RegExp(tokens.pad + "|" + tokens.indent, "g"), "");
      if (oneLined.length <= options2.inlineCharacterLimit) {
        return oneLined;
      }
      return string.replace(new RegExp(tokens.newline + "|" + tokens.newlineOrSpace, "g"), "\n").replace(new RegExp(tokens.pad, "g"), pad2).replace(new RegExp(tokens.indent, "g"), pad2 + indent);
    };
    if (seen.includes(input2)) {
      return '"[Circular]"';
    }
    if (input2 === null || input2 === void 0 || typeof input2 === "number" || typeof input2 === "boolean" || typeof input2 === "function" || typeof input2 === "symbol" || isRegexp(input2)) {
      return String(input2);
    }
    if (input2 instanceof Date) {
      return `new Date('${input2.toISOString()}')`;
    }
    if (Array.isArray(input2)) {
      if (input2.length === 0) {
        return "[]";
      }
      seen.push(input2);
      const returnValue = "[" + tokens.newline + input2.map((element, i) => {
        const eol = input2.length - 1 === i ? tokens.newline : "," + tokens.newlineOrSpace;
        let value = stringify2(element, options2, pad2 + indent);
        if (options2.transform) {
          value = options2.transform(input2, i, value);
        }
        return tokens.indent + value + eol;
      }).join("") + tokens.pad + "]";
      seen.pop();
      return expandWhiteSpace(returnValue);
    }
    if (isObject(input2)) {
      let objectKeys = getOwnEnumerableKeys(input2);
      if (options2.filter) {
        objectKeys = objectKeys.filter((element) => options2.filter(input2, element));
      }
      if (objectKeys.length === 0) {
        return "{}";
      }
      seen.push(input2);
      const returnValue = "{" + tokens.newline + objectKeys.map((element, index) => {
        const eol = objectKeys.length - 1 === index ? tokens.newline : "," + tokens.newlineOrSpace;
        const isSymbol = typeof element === "symbol";
        const isClassic = !isSymbol && /^[a-z$_][$\w]*$/i.test(element);
        const key = isSymbol || isClassic ? element : stringify2(element, options2);
        let value = stringify2(input2[element], options2, pad2 + indent);
        if (options2.transform) {
          value = options2.transform(input2, element, value);
        }
        return tokens.indent + String(key) + ": " + value + eol;
      }).join("") + tokens.pad + "}";
      seen.pop();
      return expandWhiteSpace(returnValue);
    }
    input2 = input2.replace(/\\/g, "\\\\");
    input2 = String(input2).replace(/[\r\n]/g, (x) => x === "\n" ? "\\n" : "\\r");
    if (options2.singleQuotes === false) {
      input2 = input2.replace(/"/g, '\\"');
      return `"${input2}"`;
    }
    input2 = input2.replace(/'/g, "\\'");
    return `'${input2}'`;
  }(input, options, pad);
}

// src/index.ts
var registryUUIDRegex = /^@(?<project>[a-zA-Z0-9-_]+)(\/?(?<version>.+))?#(?<uuid>[a-z0-9]+)$/;
function getProjectPrefixFromRegistryUUID(uri) {
  const matches = uri.match(registryUUIDRegex);
  if (!matches) {
    return void 0;
  }
  return matches.groups?.project;
}
function stringify(obj, opts = {}) {
  return stringifyObject(obj, { indent: "  ", ...opts });
}
function buildAuthSnippet(sdkVariable, authKey) {
  if (Array.isArray(authKey)) {
    const auth = [];
    authKey.forEach((token, i) => {
      if (token.length === 0 && authKey.length > 1 && i === authKey.length - 1) {
        return;
      }
      auth.push(`'${token.replace(/'/g, "\\'")}'`);
    });
    return `${sdkVariable}.auth(${auth.join(", ")});`;
  }
  return `${sdkVariable}.auth('${authKey.replace(/'/g, "\\'")}');`;
}
function getAuthSources(operation) {
  const matchers = {
    header: {},
    query: [],
    cookie: []
  };
  if (operation.getSecurity().length === 0) {
    return matchers;
  }
  Object.entries(operation.prepareSecurity()).forEach(([, schemes]) => {
    schemes.forEach((scheme) => {
      if (scheme.type === "http") {
        if (scheme.scheme === "basic") {
          matchers.header.authorization = "Basic";
        } else if (scheme.scheme === "bearer") {
          matchers.header.authorization = "Bearer";
        }
      } else if (scheme.type === "oauth2") {
        matchers.header.authorization = "Bearer";
      } else if (scheme.type === "apiKey") {
        if (scheme.in === "query") {
          matchers.query.push(scheme.name);
        } else if (scheme.in === "header") {
          matchers.header[scheme.name.toLowerCase()] = "*";
        } else if (scheme.in === "cookie") {
          matchers.cookie.push(scheme.name);
        }
      }
    });
  });
  return matchers;
}
var client = {
  info: {
    key: "api",
    title: "API",
    link: "https://npm.im/api",
    description: "Automatic SDK generation from an OpenAPI definition.",
    extname: ".js",
    installation: "npx api install {packageName}"
  },
  convert: ({ cookiesObj, headersObj, postData, queryObj, url, ...source }, options) => {
    const opts = {
      ...options
    };
    if (!opts?.api) {
      throw new Error("This HTTPSnippet client must have an `api` config supplied to it.");
    } else if (!opts?.api?.definition) {
      throw new Error("This HTTPSnippet client must have an `api.definition` option supplied to it.");
    } else if (!opts?.api?.registryURI) {
      throw new Error("This HTTPSnippet client must have an `api.registryURI` option supplied to it.");
    }
    const method = source.method.toLowerCase();
    const oas = new Oas(opts.api.definition);
    const apiDefinition = oas.getDefinition();
    const foundOperation = oas.findOperation(url, method);
    if (!foundOperation) {
      throw new Error(
        `Unable to locate a matching operation in the supplied \`api.definition\` for: ${source.method} ${url}`
      );
    }
    let sdkPackageName;
    let sdkVariable;
    if (opts.api.identifier) {
      sdkPackageName = opts.api.identifier;
      sdkVariable = camelCase(opts.api.identifier);
      if (isReservedOrBuiltinsLC(sdkVariable)) {
        sdkVariable = `_${sdkVariable}`;
      }
    } else {
      sdkPackageName = getProjectPrefixFromRegistryUUID(opts.api.registryURI);
      sdkVariable = "sdk";
    }
    const operationSlugs = foundOperation.url.slugs;
    const operation = oas.operation(foundOperation.url.nonNormalizedPath, method);
    const operationPathParameters = operation.getParameters().filter((param) => param.in === "path");
    const path = operation.path;
    const authData = [];
    const authSources = getAuthSources(operation);
    const { blank, push, join } = new CodeBuilder({ indent: opts.indent || "  " });
    push(`import ${sdkVariable} from '@api/${sdkPackageName}';`);
    blank();
    const configData = [];
    if ((apiDefinition.servers || []).length > 1) {
      const stockUrl = oas.url();
      const baseUrl = url.replace(path, "");
      if (baseUrl !== stockUrl) {
        const serverVars = oas.splitVariables(baseUrl);
        const serverUrl = serverVars ? oas.url(serverVars.selected, serverVars.variables) : baseUrl;
        configData.push(`sdk.server('${serverUrl}');`);
      }
    }
    let metadata = {};
    Object.keys(queryObj).forEach((param) => {
      if (authSources.query.includes(param)) {
        authData.push(buildAuthSnippet(sdkVariable, queryObj[param]));
        return;
      }
      metadata[param] = queryObj[param];
    });
    Object.keys(cookiesObj).forEach((cookie) => {
      if (authSources.cookie.includes(cookie)) {
        authData.push(buildAuthSnippet(sdkVariable, cookiesObj[cookie]));
        return;
      }
      metadata[cookie] = cookiesObj[cookie];
    });
    Array.from(Object.entries(operationSlugs)).forEach(([param, value]) => {
      const cleanedParam = param.substring(1);
      const unsanitizedParam = operationPathParameters.find((p) => {
        return p.name.includes("-") && p.name.replace(/-/g, "") === cleanedParam ? p.name : false;
      });
      if (unsanitizedParam) {
        metadata[unsanitizedParam.name] = value;
      } else {
        metadata[cleanedParam] = value;
      }
    });
    if (Object.keys(headersObj).length) {
      const headers = headersObj;
      const requestHeaders = {};
      Object.keys(headers).forEach((header) => {
        const headerLower = header.toLowerCase();
        if (headerLower in authSources.header) {
          const authScheme = authSources.header[headerLower];
          if (authScheme === "*") {
            authData.push(buildAuthSnippet(sdkVariable, headers[header]));
          } else {
            let authKey = headers[header].replace(`${authSources.header[headerLower]} `, "");
            if (authScheme.toLowerCase() === "basic") {
              authKey = Buffer.from(authKey, "base64").toString("ascii");
              authKey = authKey.split(":");
            }
            authData.push(buildAuthSnippet(sdkVariable, authKey));
          }
          delete headers[header];
          return;
        } else if (headerLower === "content-type") {
          const parsedContentType = contentType.parse(headers[header]);
          if (!Object.keys(parsedContentType.parameters).length) {
            delete headers[header];
            return;
          }
        } else if (headerLower === "accept") {
          if (matchesMimeType.json(headers[header])) {
            delete headers[header];
            return;
          }
        }
        if (["accept", "content-type"].includes(headerLower)) {
          requestHeaders[headerLower] = headers[header];
        } else {
          requestHeaders[header] = headers[header];
        }
      });
      if (Object.keys(requestHeaders).length > 0) {
        metadata = Object.assign(metadata, requestHeaders);
      }
    }
    let body;
    switch (postData.mimeType) {
      case "application/x-www-form-urlencoded":
        body = postData.paramsObj;
        break;
      case "application/json":
        if (postData.jsonObj) {
          body = postData.jsonObj;
        }
        break;
      case "multipart/form-data":
        if (postData.params) {
          body = {};
          if ("content-type" in metadata && metadata["content-type"].indexOf("multipart/form-data") === 0) {
            delete metadata["content-type"];
          }
          postData.params.forEach((param) => {
            if (param.fileName) {
              body[param.name] = param.fileName;
            } else {
              body[param.name] = param.value;
            }
          });
        }
        break;
      default:
        if (postData.text) {
          body = postData.text;
        }
    }
    const args = [];
    const accessor = operation.getOperationId({ camelCase: true });
    const inlineCharacterLimit = typeof body !== "undefined" && Object.keys(metadata).length > 0 ? 40 : 80;
    if (typeof body !== "undefined") {
      args.push(stringify(body, { inlineCharacterLimit }));
    }
    if (Object.keys(metadata).length > 0) {
      args.push(stringify(metadata, { inlineCharacterLimit }));
    }
    if (authData.length) {
      push(authData.join("\n"));
    }
    if (configData.length) {
      push(configData.join("\n"));
    }
    push(`${sdkVariable}.${accessor}(${args.join(", ")})`);
    push(".then(({ data }) => console.log(data))", 1);
    push(".catch(err => console.error(err));", 1);
    return join();
  }
};
var plugin = {
  target: "node",
  client
};
var src_default = plugin;
export {
  src_default as default
};
//# sourceMappingURL=index.js.map