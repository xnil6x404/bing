{"version":3,"sources":["../src/operation/lib/dedupe-common-parameters.ts","../src/samples/index.ts","../src/samples/utils.ts","../src/operation/lib/get-mediatype-examples.ts","../src/operation/lib/get-response-examples.ts","../src/operation/lib/get-callback-examples.ts","../src/operation/lib/get-requestbody-examples.ts","../src/operation/lib/get-response-as-json-schema.ts","../src/operation/index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RMOAS from '../../types.js';\n\n/**\n * With an array of common parameters filter down them to what isn't already present in a list of\n * non-common parameters.\n *\n * @param parameters Array of parameters defined at the operation level.\n * @param commonParameters Array of **common** parameters defined at the path item level.\n */\nexport function dedupeCommonParameters(parameters: RMOAS.ParameterObject[], commonParameters: RMOAS.ParameterObject[]) {\n  return commonParameters.filter((param: RMOAS.ParameterObject) => {\n    return !parameters.find((param2: RMOAS.ParameterObject) => {\n      if (param.name && param2.name) {\n        return param.name === param2.name && param.in === param2.in;\n      } else if (RMOAS.isRef(param) && RMOAS.isRef(param2)) {\n        return param.$ref === param2.$ref;\n      }\n\n      return false;\n    });\n  });\n}\n","/**\n * This file has been extracted and modified from Swagger UI.\n *\n * @license Apache-2.0\n * @see {@link https://github.com/swagger-api/swagger-ui/blob/master/src/core/plugins/samples/fn.js}\n */\nimport type * as RMOAS from '../types.js';\n\nimport mergeJSONSchemaAllOf from 'json-schema-merge-allof';\nimport memoize from 'memoizee';\n\nimport { objectify, usesPolymorphism, isFunc, normalizeArray, deeplyStripKey } from './utils.js';\n\nconst sampleDefaults = (genericSample: string | number | boolean) => {\n  return (schema: RMOAS.SchemaObject): typeof genericSample =>\n    typeof schema.default === typeof genericSample ? schema.default : genericSample;\n};\n\nconst primitives: Record<string, (arg: void | RMOAS.SchemaObject) => string | number | boolean> = {\n  string: sampleDefaults('string'),\n  string_email: sampleDefaults('user@example.com'),\n  'string_date-time': sampleDefaults(new Date().toISOString()),\n  string_date: sampleDefaults(new Date().toISOString().substring(0, 10)),\n  'string_YYYY-MM-DD': sampleDefaults(new Date().toISOString().substring(0, 10)),\n  string_uuid: sampleDefaults('3fa85f64-5717-4562-b3fc-2c963f66afa6'),\n  string_hostname: sampleDefaults('example.com'),\n  string_ipv4: sampleDefaults('198.51.100.42'),\n  string_ipv6: sampleDefaults('2001:0db8:5b96:0000:0000:426f:8e17:642a'),\n  number: sampleDefaults(0),\n  number_float: sampleDefaults(0.0),\n  integer: sampleDefaults(0),\n  boolean: sampleDefaults(true),\n};\n\nconst primitive = (schema: RMOAS.SchemaObject) => {\n  schema = objectify(schema);\n  const { format } = schema;\n  let { type } = schema;\n\n  if (type === 'null') {\n    return null;\n  } else if (Array.isArray(type)) {\n    if (type.length === 1) {\n      type = type[0];\n    } else {\n      // If one of our types is `null` then we should generate a sample for the non-null value.\n      if (type.includes('null')) {\n        type = type.filter(t => t !== 'null');\n      }\n\n      type = type.shift();\n    }\n  }\n\n  // @todo add support for if `type` is an array\n  const fn = primitives[`${type}_${format}`] || primitives[type as string];\n  if (isFunc(fn)) {\n    return fn(schema);\n  }\n\n  return `Unknown Type: ${schema.type}`;\n};\n\n/**\n * Generate a piece of sample data from a JSON Schema object. If `example` declarations are present\n * they will be utilized, but generally this will generate fake data for the information present in\n * the schema.\n *\n * @param schema JSON Schema to generate a sample for.\n */\nfunction sampleFromSchema(\n  schema: RMOAS.SchemaObject,\n  opts: {\n    /**\n     * If you wish to include data that's flagged as `readOnly`.\n     */\n    includeReadOnly?: boolean;\n\n    /**\n     * If you wish to include data that's flatted as `writeOnly`.\n     */\n    includeWriteOnly?: boolean;\n  } = {},\n): string | number | boolean | null | unknown[] | Record<string, unknown> | undefined {\n  const objectifySchema = objectify(schema);\n  let { type } = objectifySchema;\n\n  const hasPolymorphism = usesPolymorphism(objectifySchema);\n  if (hasPolymorphism === 'allOf') {\n    try {\n      return sampleFromSchema(\n        mergeJSONSchemaAllOf(objectifySchema, {\n          resolvers: {\n            // Ignore any unrecognized OAS-specific keywords that might be present on the schema\n            // (like `xml`).\n            defaultResolver: mergeJSONSchemaAllOf.options.resolvers.title,\n          },\n        }),\n        opts,\n      );\n    } catch (error) {\n      return undefined;\n    }\n  } else if (hasPolymorphism) {\n    const samples = (objectifySchema[hasPolymorphism] as RMOAS.SchemaObject[]).map(s => {\n      return sampleFromSchema(s, opts);\n    });\n\n    if (samples.length === 1) {\n      return samples[0];\n    } else if (samples.some(s => s === null)) {\n      // If one of our samples is null then we should try to surface the first non-null one.\n      return samples.find(s => s !== null);\n    }\n\n    // If we still don't have a sample then we should just return whatever the first sample we've\n    // got is. The sample might not be a _full_ example but it should be enough to act as a sample.\n    return samples[0];\n  }\n\n  const { example, additionalProperties, properties, items } = objectifySchema;\n  const { includeReadOnly, includeWriteOnly } = opts;\n\n  if (example !== undefined) {\n    return deeplyStripKey(example, '$$ref', (val: string) => {\n      // do a couple of quick sanity tests to ensure the value\n      // looks like a $$ref that swagger-client generates.\n      return typeof val === 'string' && val.indexOf('#') > -1;\n    });\n  }\n\n  if (!type) {\n    if (properties || additionalProperties) {\n      type = 'object';\n    } else if (items) {\n      type = 'array';\n    } else {\n      return undefined;\n    }\n  }\n\n  if (type === 'object' || (Array.isArray(type) && type.includes('object'))) {\n    const props = objectify(properties);\n    const obj: Record<string, any> = {};\n    // eslint-disable-next-line no-restricted-syntax\n    for (const name in props) {\n      if (props[name] && props[name].deprecated) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (props[name] && props[name].readOnly && !includeReadOnly) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (props[name] && props[name].writeOnly && !includeWriteOnly) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      obj[name] = sampleFromSchema(props[name], opts);\n    }\n\n    if (additionalProperties === true) {\n      obj.additionalProp = {};\n    } else if (additionalProperties) {\n      const additionalProps = objectify(additionalProperties);\n      const additionalPropVal = sampleFromSchema(additionalProps, opts);\n\n      obj.additionalProp = additionalPropVal;\n    }\n\n    return obj;\n  }\n\n  if (type === 'array' || (Array.isArray(type) && type.includes('array'))) {\n    // `items` should always be present on arrays, but if it isn't we should at least do our best\n    // to support its absence.\n    if (typeof items === 'undefined') {\n      return [];\n    }\n\n    if (Array.isArray(items.anyOf)) {\n      return items.anyOf.map((i: RMOAS.SchemaObject) => sampleFromSchema(i, opts));\n    }\n\n    if (Array.isArray(items.oneOf)) {\n      return items.oneOf.map((i: RMOAS.SchemaObject) => sampleFromSchema(i, opts));\n    }\n\n    return [sampleFromSchema(items, opts)];\n  }\n\n  if (schema.enum) {\n    if (schema.default) {\n      return schema.default;\n    }\n\n    return normalizeArray(schema.enum as string[])[0];\n  }\n\n  if (type === 'file') {\n    return undefined;\n  }\n\n  return primitive(schema);\n}\n\nexport default memoize(sampleFromSchema);\n","/**\n * Portions of this file have been extracted and modified from Swagger UI.\n *\n * @license Apache-2.0\n * @see {@link https://github.com/swagger-api/swagger-ui/blob/master/src/core/utils.js}\n */\nimport type * as RMOAS from '../types.js';\n\nimport { isObject } from '../lib/helpers.js';\n\nexport function usesPolymorphism(schema: RMOAS.SchemaObject) {\n  if (schema.oneOf) {\n    return 'oneOf';\n  } else if (schema.anyOf) {\n    return 'anyOf';\n  } else if (schema.allOf) {\n    return 'allOf';\n  }\n\n  return false;\n}\n\nexport function objectify(thing: unknown | Record<string, unknown>): Record<string, any> {\n  if (!isObject(thing)) {\n    return {};\n  }\n\n  return thing;\n}\n\nexport function normalizeArray(arr: string | number | (string | number)[]) {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n\n  return [arr];\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunc(thing: unknown): thing is Function {\n  return typeof thing === 'function';\n}\n\n// Deeply strips a specific key from an object.\n//\n// `predicate` can be used to discriminate the stripping further,\n// by preserving the key's place in the object based on its value.\n// @todo make this have a better type than `any`\nexport function deeplyStripKey(\n  input: unknown,\n  keyToStrip: string,\n  predicate = (obj: unknown, key?: string): boolean => true, // eslint-disable-line @typescript-eslint/no-unused-vars\n): any | RMOAS.SchemaObject {\n  if (typeof input !== 'object' || Array.isArray(input) || input === null || !keyToStrip) {\n    return input;\n  }\n\n  const obj = { ...input } as Record<string, RMOAS.SchemaObject>;\n\n  Object.keys(obj).forEach(k => {\n    if (k === keyToStrip && predicate(obj[k], k)) {\n      delete obj[k];\n      return;\n    }\n\n    obj[k] = deeplyStripKey(obj[k], keyToStrip, predicate);\n  });\n\n  return obj;\n}\n","import type * as RMOAS from '../../types.js';\n\nimport matchesMimeType from '../../lib/matches-mimetype.js';\nimport sampleFromSchema from '../../samples/index.js';\n\nexport interface MediaTypeExample {\n  description?: string;\n  summary?: string;\n  title?: string;\n  value: unknown;\n}\n\n/**\n * Extracts a collection of examples from an OpenAPI Media Type Object. The example will either\n * come from the `example` property, the first item in an `examples` array, or if none of those are\n * present it will generate an example based off its schema.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#mediaTypeObject}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#mediaTypeObject}\n * @param mediaType The media type that we're looking for examples for.\n * @param mediaTypeObject The media type object that we're looking for examples for.\n */\nexport function getMediaTypeExamples(\n  mediaType: string,\n  mediaTypeObject: RMOAS.MediaTypeObject,\n  opts: {\n    /**\n     * If you wish to include data that's flagged as `readOnly`.\n     */\n    includeReadOnly?: boolean;\n\n    /**\n     * If you wish to include data that's flatted as `writeOnly`.\n     */\n    includeWriteOnly?: boolean;\n  } = {},\n) {\n  if (mediaTypeObject.example) {\n    return [\n      {\n        value: mediaTypeObject.example,\n      },\n    ];\n  } else if (mediaTypeObject.examples) {\n    const { examples } = mediaTypeObject;\n    const multipleExamples = Object.keys(examples)\n      .map(key => {\n        let summary = key;\n        let description;\n\n        let example = examples[key];\n        if (example !== null && typeof example === 'object') {\n          if ('summary' in example) {\n            summary = example.summary;\n          }\n\n          if ('description' in example) {\n            description = example.description;\n          }\n\n          if ('value' in example) {\n            // If we have a $ref here then it's a circular reference and we should ignore it.\n            if (example.value !== null && typeof example.value === 'object' && '$ref' in example.value) {\n              return false;\n            }\n\n            example = example.value;\n          }\n        }\n\n        const ret: MediaTypeExample = { summary, title: key, value: example };\n        if (description) {\n          ret.description = description;\n        }\n\n        return ret;\n      })\n      .filter(Boolean) as MediaTypeExample[];\n\n    // If we were able to grab examples from the `examples` property return them (`examples` can\n    // sometimes be an empty object), otherwise we should try to generate some instead.\n    if (multipleExamples.length) {\n      return multipleExamples;\n    }\n  }\n\n  if (mediaTypeObject.schema) {\n    // We do not fully support XML so we shouldn't generate XML samples for XML schemas.\n    if (!matchesMimeType.xml(mediaType)) {\n      return [\n        {\n          value: sampleFromSchema(JSON.parse(JSON.stringify(mediaTypeObject.schema)), opts),\n        },\n      ];\n    }\n  }\n\n  return [];\n}\n","import type { MediaTypeExample } from './get-mediatype-examples.js';\nimport type * as RMOAS from '../../types.js';\n\nimport { isRef } from '../../types.js';\n\nimport { getMediaTypeExamples } from './get-mediatype-examples.js';\n\nexport type ResponseExamples = {\n  mediaTypes: Record<string, MediaTypeExample[]>;\n  onlyHeaders?: boolean;\n  status: string;\n}[];\n\n/**\n * Retrieve a collection of response examples keyed, by their media type.\n *\n * @param operation Operation to retrieve response examples for.\n */\nexport function getResponseExamples(operation: RMOAS.OperationObject) {\n  return Object.keys(operation.responses || {})\n    .map(status => {\n      const response = operation.responses[status];\n      let onlyHeaders = false;\n\n      // If we have a $ref here that means that this was a circular ref so we should ignore it.\n      if (isRef(response)) {\n        return false;\n      }\n\n      const mediaTypes: Record<string, MediaTypeExample[]> = {};\n      (response.content ? Object.keys(response.content) : []).forEach(mediaType => {\n        if (!mediaType) return;\n\n        const mediaTypeObject = response.content[mediaType];\n        const examples = getMediaTypeExamples(mediaType, mediaTypeObject, {\n          includeReadOnly: true,\n          includeWriteOnly: false,\n        });\n\n        if (examples) {\n          mediaTypes[mediaType] = examples;\n        }\n      });\n\n      // If the response has no content, but has headers, hardcode an empty example so the headers\n      // modal will still display\n      if (response.headers && Object.keys(response.headers).length && !Object.keys(mediaTypes).length) {\n        mediaTypes['*/*'] = [];\n        onlyHeaders = true;\n      }\n\n      if (!Object.keys(mediaTypes).length) {\n        return false;\n      }\n\n      return {\n        status,\n        mediaTypes,\n        ...(onlyHeaders ? { onlyHeaders } : {}),\n      };\n    })\n    .filter(Boolean) as ResponseExamples;\n}\n","import type * as RMOAS from '../../types.js';\n\nimport { getResponseExamples } from './get-response-examples.js';\n\nexport type CallbackExamples = {\n  example: unknown;\n  expression: string;\n  identifier: string;\n  method: string;\n}[];\n\n/**\n * With an OpenAPI Operation Object return back a collection of examples for any callbacks that may\n * be present.\n *\n * @param operation Operation to retrieve callback examples from.\n */\nexport function getCallbackExamples(operation: RMOAS.OperationObject) {\n  const ret: CallbackExamples = [];\n\n  // spreads the contents of the map for each callback so there's not nested arrays returned\n  return ret.concat(\n    ...Object.keys(operation.callbacks || {}).map(identifier => {\n      const callback = operation.callbacks[identifier] as RMOAS.CallbackObject;\n\n      // spreads the contents again so there's not nested arrays returned\n      return []\n        .concat(\n          ...Object.keys(callback).map(expression => {\n            return Object.keys(callback[expression]).map(method => {\n              const pathItem = callback[expression] as Record<string, RMOAS.OperationObject>;\n              const example = getResponseExamples(pathItem[method]);\n              if (example.length === 0) return false;\n\n              return {\n                identifier,\n                expression,\n                method,\n                example,\n              };\n            });\n          }),\n        )\n        .filter(Boolean);\n    }),\n  );\n}\n","import type * as RMOAS from '../../types.js';\n\nimport { getMediaTypeExamples } from './get-mediatype-examples.js';\n\nexport type RequestBodyExamples = {\n  examples: any;\n  mediaType: string;\n}[];\n\n/**\n * Retrieve a collection of request body examples, keyed by their media type.\n *\n * @param operation Operation to retrieve requestBody examples for.\n */\nexport function getRequestBodyExamples(operation: RMOAS.OperationObject) {\n  // `requestBody` will never have `$ref` pointers here so we need to work around the type that we\n  // have from `RMOAS.OperationObject`.\n  const requestBody = operation.requestBody as RMOAS.RequestBodyObject;\n  if (!requestBody || !requestBody.content) {\n    return [];\n  }\n\n  return Object.keys(requestBody.content || {})\n    .map(mediaType => {\n      const mediaTypeObject = requestBody.content[mediaType];\n      const examples = getMediaTypeExamples(mediaType, mediaTypeObject, {\n        includeReadOnly: false,\n        includeWriteOnly: true,\n      });\n\n      if (!examples.length) {\n        return false;\n      }\n\n      return {\n        mediaType,\n        examples,\n      };\n    })\n    .filter(Boolean) as RequestBodyExamples;\n}\n","import type {\n  ComponentsObject,\n  MediaTypeObject,\n  OASDocument,\n  ResponseObject,\n  SchemaObject,\n  HeaderObject,\n} from '../../types.js';\nimport type { Operation } from '../index.js';\n\nimport cloneObject from '../../lib/clone-object.js';\nimport { isPrimitive } from '../../lib/helpers.js';\nimport matches from '../../lib/matches-mimetype.js';\nimport { toJSONSchema, getSchemaVersionString } from '../../lib/openapi-to-json-schema.js';\n\nconst isJSON = matches.json;\n\n/**\n * Turn a header map from OpenAPI 3.0.3 (and some earlier versions too) into a schema.\n *\n * Note: This does not support OpenAPI 3.1.0's header format.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#headerObject}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.3.md#headerObject}\n * @param response Response object to build a JSON Schema object for its headers for.\n */\nfunction buildHeadersSchema(\n  response: ResponseObject,\n  opts?: {\n    /**\n     * With a transformer you can transform any data within a given schema, like say if you want to\n     * rewrite a potentially unsafe `title` that might be eventually used as a JS variable name,\n     * just make sure to return your transformed schema.\n     */\n    transformer?: (schema: SchemaObject) => SchemaObject;\n  },\n) {\n  const headers = response.headers;\n\n  const headersSchema: SchemaObject = {\n    type: 'object',\n    properties: {},\n  };\n\n  Object.keys(headers).forEach(key => {\n    if (headers[key] && (headers[key] as HeaderObject).schema) {\n      const header: HeaderObject = headers[key] as HeaderObject;\n\n      // TODO: Response headers are essentially parameters in OAS\n      //    This means they can have content instead of schema.\n      //    We should probably support that in the future\n      headersSchema.properties[key] = toJSONSchema(header.schema, {\n        addEnumsToDescriptions: true,\n        transformer: opts.transformer,\n      });\n\n      if (header.description) {\n        (headersSchema.properties[key] as HeaderObject).description = header.description;\n      }\n    }\n  });\n\n  const headersWrapper: {\n    description?: string;\n    label: string;\n    schema: SchemaObject;\n    type: string;\n  } = {\n    schema: headersSchema,\n    type: 'object',\n    label: 'Headers',\n  };\n\n  if (response.description && headersWrapper.schema) {\n    headersWrapper.description = response.description;\n  }\n\n  return headersWrapper;\n}\n\n/**\n * Extract all the response schemas, matching the format of `get-parameters-as-json-schema`.\n *\n * Note: This expects a dereferenced schema.\n *\n * @param operation Operation to construct a response JSON Schema for.\n * @param api The OpenAPI definition that this operation originates.\n * @param statusCode The response status code to generate a schema for.\n */\nexport function getResponseAsJSONSchema(\n  operation: Operation,\n  api: OASDocument,\n  statusCode: string | number,\n  opts?: {\n    includeDiscriminatorMappingRefs?: boolean;\n    /**\n     * With a transformer you can transform any data within a given schema, like say if you want\n     * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable\n     * name, just make sure to return your transformed schema.\n     */\n    transformer?: (schema: SchemaObject) => SchemaObject;\n  },\n) {\n  const response = operation.getResponseByStatusCode(statusCode);\n  const jsonSchema = [];\n\n  if (!response) {\n    return null;\n  }\n\n  let hasCircularRefs = false;\n  let hasDiscriminatorMappingRefs = false;\n\n  function refLogger(ref: string, type: 'ref' | 'discriminator') {\n    if (type === 'ref') {\n      hasCircularRefs = true;\n    } else {\n      hasDiscriminatorMappingRefs = true;\n    }\n  }\n\n  /**\n   * @param content An array of `MediaTypeObject`'s to retrieve a preferred schema out of. We\n   *    prefer JSON media types.\n   */\n  function getPreferredSchema(content: Record<string, MediaTypeObject>) {\n    if (!content) {\n      return null;\n    }\n\n    const contentTypes = Object.keys(content);\n    if (!contentTypes.length) {\n      return null;\n    }\n\n    // eslint-disable-next-line no-plusplus\n    for (let i = 0; i < contentTypes.length; i++) {\n      if (isJSON(contentTypes[i])) {\n        return toJSONSchema(cloneObject(content[contentTypes[i]].schema), {\n          addEnumsToDescriptions: true,\n          refLogger,\n          transformer: opts.transformer,\n        });\n      }\n    }\n\n    // We always want to prefer the JSON-compatible content types over everything else but if we\n    // haven't found one we should default to the first available.\n    const contentType = contentTypes.shift();\n    return toJSONSchema(cloneObject(content[contentType].schema), {\n      addEnumsToDescriptions: true,\n      refLogger,\n      transformer: opts.transformer,\n    });\n  }\n\n  const foundSchema = getPreferredSchema((response as ResponseObject).content);\n  if (foundSchema) {\n    const schema = cloneObject(foundSchema);\n    const schemaWrapper: {\n      description?: string;\n      label: string;\n      schema: SchemaObject;\n      type: string | string[];\n    } = {\n      // If there's no `type` then the root schema is a circular `$ref` that we likely won't be\n      // able to render so instead of generating a JSON Schema with an `undefined` type we should\n      // default to `string` so there's at least *something* the end-user can interact with.\n      type: foundSchema.type || 'string',\n      schema: isPrimitive(schema)\n        ? schema\n        : {\n            ...schema,\n            $schema: getSchemaVersionString(schema, api),\n          },\n      label: 'Response body',\n    };\n\n    if ((response as ResponseObject).description && schemaWrapper.schema) {\n      schemaWrapper.description = (response as ResponseObject).description;\n    }\n\n    /**\n     * Since this library assumes that the schema has already been dereferenced, adding every\n     * component here that **isn't** circular adds a ton of bloat so it'd be cool if `components`\n     * was just the remaining `$ref` pointers that are still being referenced.\n     *\n     * @todo\n     */\n    if (api.components && schemaWrapper.schema) {\n      // We should only include components if we've got circular refs or we have discriminator\n      // mapping refs (we want to include them).\n      if (hasCircularRefs || (hasDiscriminatorMappingRefs && opts.includeDiscriminatorMappingRefs)) {\n        ((schemaWrapper.schema as SchemaObject).components as ComponentsObject) = api.components as ComponentsObject;\n      }\n    }\n\n    jsonSchema.push(schemaWrapper);\n  }\n\n  // 3.0.3 and earlier headers. TODO: New format for 3.1.0\n  if ((response as ResponseObject).headers) {\n    jsonSchema.push(buildHeadersSchema(response as ResponseObject, opts));\n  }\n\n  return jsonSchema.length ? jsonSchema : null;\n}\n","import type { CallbackExamples } from './lib/get-callback-examples.js';\nimport type { getParametersAsJSONSchemaOptions } from './lib/get-parameters-as-json-schema.js';\nimport type { RequestBodyExamples } from './lib/get-requestbody-examples.js';\nimport type { ResponseExamples } from './lib/get-response-examples.js';\nimport type { OpenAPIV3, OpenAPIV3_1 } from 'openapi-types';\n\nimport findSchemaDefinition from '../lib/find-schema-definition.js';\nimport matchesMimeType from '../lib/matches-mimetype.js';\nimport * as RMOAS from '../types.js';\nimport { supportedMethods } from '../utils.js';\n\nimport { dedupeCommonParameters } from './lib/dedupe-common-parameters.js';\nimport { getCallbackExamples } from './lib/get-callback-examples.js';\nimport { getParametersAsJSONSchema } from './lib/get-parameters-as-json-schema.js';\nimport { getRequestBodyExamples } from './lib/get-requestbody-examples.js';\nimport { getResponseAsJSONSchema } from './lib/get-response-as-json-schema.js';\nimport { getResponseExamples } from './lib/get-response-examples.js';\n\ntype SecurityType = 'Basic' | 'Bearer' | 'Query' | 'Header' | 'Cookie' | 'OAuth2' | 'http' | 'apiKey';\n\nexport class Operation {\n  /**\n   * Schema of the operation from the API Definition.\n   */\n  schema: RMOAS.OperationObject;\n\n  /**\n   * OpenAPI API Definition that this operation originated from.\n   */\n  api: RMOAS.OASDocument;\n\n  /**\n   * Path that this operation is targeted towards.\n   */\n  path: string;\n\n  /**\n   * HTTP Method that this operation is targeted towards.\n   */\n  method: RMOAS.HttpMethods;\n\n  /**\n   * The primary Content Type that this operation accepts.\n   */\n  contentType: string;\n\n  /**\n   * Request body examples for this operation.\n   */\n  requestBodyExamples: RequestBodyExamples;\n\n  /**\n   * Response examples for this operation.\n   */\n  responseExamples: ResponseExamples;\n\n  /**\n   * Callback examples for this operation (if it has callbacks).\n   */\n  callbackExamples: CallbackExamples;\n\n  /**\n   * Flattened out arrays of both request and response headers that are utilized on this operation.\n   */\n  headers: {\n    request: string[];\n    response: string[];\n  };\n\n  constructor(api: RMOAS.OASDocument, path: string, method: RMOAS.HttpMethods, operation: RMOAS.OperationObject) {\n    this.schema = operation;\n    this.api = api;\n    this.path = path;\n    this.method = method;\n\n    this.contentType = undefined;\n    this.requestBodyExamples = undefined;\n    this.responseExamples = undefined;\n    this.callbackExamples = undefined;\n  }\n\n  getSummary(): string {\n    if (this.schema?.summary && typeof this.schema.summary === 'string') {\n      return this.schema.summary;\n    } else if (this.api.paths[this.path].summary && typeof this.api.paths[this.path].summary === 'string') {\n      return this.api.paths[this.path].summary;\n    }\n\n    return undefined;\n  }\n\n  getDescription(): string {\n    if (this.schema?.description && typeof this.schema.description === 'string') {\n      return this.schema.description;\n    } else if (this.api.paths[this.path].description && typeof this.api.paths[this.path].description === 'string') {\n      return this.api.paths[this.path].description;\n    }\n\n    return undefined;\n  }\n\n  getContentType(): string {\n    if (this.contentType) {\n      return this.contentType;\n    }\n\n    let types: string[] = [];\n    if (this.schema.requestBody) {\n      if ('$ref' in this.schema.requestBody) {\n        this.schema.requestBody = findSchemaDefinition(this.schema.requestBody.$ref, this.api);\n      }\n\n      if ('content' in this.schema.requestBody) {\n        types = Object.keys(this.schema.requestBody.content);\n      }\n    }\n\n    this.contentType = 'application/json';\n    if (types && types.length) {\n      this.contentType = types[0];\n    }\n\n    // Favor JSON if it exists\n    types.forEach(t => {\n      if (matchesMimeType.json(t)) {\n        this.contentType = t;\n      }\n    });\n\n    return this.contentType;\n  }\n\n  isFormUrlEncoded(): boolean {\n    return matchesMimeType.formUrlEncoded(this.getContentType());\n  }\n\n  isMultipart(): boolean {\n    return matchesMimeType.multipart(this.getContentType());\n  }\n\n  isJson(): boolean {\n    return matchesMimeType.json(this.getContentType());\n  }\n\n  isXml(): boolean {\n    return matchesMimeType.xml(this.getContentType());\n  }\n\n  /**\n   * Returns an array of all security requirements associated wtih this operation. If none are\n   * defined at the operation level, the securities for the entire API definition are returned\n   * (with an empty array as a final fallback).\n   *\n   */\n  getSecurity(): RMOAS.SecurityRequirementObject[] {\n    if (!this.api?.components?.securitySchemes || !Object.keys(this.api.components.securitySchemes).length) {\n      return [];\n    }\n\n    return this.schema.security || this.api.security || [];\n  }\n\n  /**\n   * Retrieve a collection of grouped security schemes. The inner array determines AND-grouped\n   * security schemes, the outer array determines OR-groups.\n   *\n   * @see {@link https://swagger.io/docs/specification/authentication/#multiple}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#security-requirement-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#securityRequirementObject}\n   * @param filterInvalid Optional flag that, when set to `true`, filters out invalid/nonexistent\n   *    security schemes, rather than returning `false`.\n   */\n  getSecurityWithTypes(\n    filterInvalid = false,\n  ): (false | (false | { security: RMOAS.KeyedSecuritySchemeObject; type: SecurityType })[])[] {\n    const securityRequirements = this.getSecurity();\n\n    return securityRequirements.map(requirement => {\n      let keys;\n      try {\n        keys = Object.keys(requirement);\n      } catch (e) {\n        return false;\n      }\n\n      const keysWithTypes = keys.map(key => {\n        let security;\n        try {\n          // Remove the reference type, because we know this will be dereferenced\n          security = this.api.components.securitySchemes[key] as RMOAS.KeyedSecuritySchemeObject;\n        } catch (e) {\n          return false;\n        }\n\n        if (!security) return false;\n\n        let type: SecurityType = null;\n\n        if (security.type === 'http') {\n          if (security.scheme === 'basic') type = 'Basic';\n          else if (security.scheme === 'bearer') type = 'Bearer';\n          else type = security.type;\n        } else if (security.type === 'oauth2') {\n          type = 'OAuth2';\n        } else if (security.type === 'apiKey') {\n          if (security.in === 'query') type = 'Query';\n          else if (security.in === 'header') type = 'Header';\n          else if (security.in === 'cookie') type = 'Cookie';\n          else type = security.type;\n        } else {\n          return false;\n        }\n\n        return {\n          type,\n          security: {\n            ...security,\n            _key: key,\n          },\n        };\n      });\n\n      if (filterInvalid) return keysWithTypes.filter(key => key !== false);\n\n      return keysWithTypes;\n    });\n  }\n\n  /**\n   * Retrieve an object where the keys are unique scheme types, and the values are arrays\n   * containing each security scheme of that type.\n   *\n   */\n  prepareSecurity(): Record<SecurityType, RMOAS.KeyedSecuritySchemeObject[]> {\n    const securitiesWithTypes = this.getSecurityWithTypes();\n\n    return securitiesWithTypes.reduce(\n      (prev, securities) => {\n        if (!securities) return prev;\n\n        securities.forEach(security => {\n          // Remove non-existent schemes\n          if (!security) return;\n          if (!prev[security.type]) prev[security.type] = [];\n\n          // Only add schemes we haven't seen yet.\n          const exists = prev[security.type].findIndex(sec => sec._key === security.security._key);\n          if (exists < 0) {\n            prev[security.type].push(security.security);\n          }\n        });\n\n        return prev;\n      },\n      {} as Record<SecurityType, RMOAS.KeyedSecuritySchemeObject[]>,\n    );\n  }\n\n  getHeaders(): Operation['headers'] {\n    this.headers = {\n      request: [],\n      response: [],\n    };\n\n    const security = this.prepareSecurity();\n    if (security.Header) {\n      this.headers.request = (security.Header as OpenAPIV3_1.ApiKeySecurityScheme[]).map(h => {\n        return h.name;\n      });\n    }\n\n    if (security.Bearer || security.Basic || security.OAuth2) {\n      this.headers.request.push('Authorization');\n    }\n\n    if (security.Cookie) {\n      this.headers.request.push('Cookie');\n    }\n\n    if (this.schema.parameters) {\n      this.headers.request = this.headers.request.concat(\n        // Remove the reference object because we will have already dereferenced.\n        (this.schema.parameters as OpenAPIV3.ParameterObject[] | OpenAPIV3_1.ParameterObject[])\n          .map(p => {\n            if (p.in && p.in === 'header') return p.name;\n            return undefined;\n          })\n          .filter(p => p),\n      );\n    }\n\n    if (this.schema.responses) {\n      this.headers.response = Object.keys(this.schema.responses)\n        // Remove the reference object because we will have already dereferenced.\n        .filter(r => (this.schema.responses[r] as RMOAS.ResponseObject).headers)\n        .map(r =>\n          // Remove the reference object because we will have already dereferenced.\n          Object.keys((this.schema.responses[r] as RMOAS.ResponseObject).headers),\n        )\n        .reduce((a, b) => a.concat(b), []);\n    }\n\n    // If the operation doesn't already specify a `content-type` request header, we check if the\n    // path operation request body contains content, which implies that we should also include the\n    // `content-type` header.\n    if (!this.headers.request.includes('Content-Type') && this.schema.requestBody) {\n      if (\n        (this.schema.requestBody as RMOAS.RequestBodyObject).content &&\n        Object.keys((this.schema.requestBody as RMOAS.RequestBodyObject).content)\n      ) {\n        this.headers.request.push('Content-Type');\n      }\n    }\n\n    // This is a similar approach, but in this case if we check the response content and prioritize\n    // the `accept` request header and `content-type` request header.\n    if (this.schema.responses) {\n      if (\n        Object.keys(this.schema.responses).some(\n          response => !!(this.schema.responses[response] as RMOAS.ResponseObject).content,\n        )\n      ) {\n        if (!this.headers.request.includes('Accept')) this.headers.request.push('Accept');\n        if (!this.headers.response.includes('Content-Type')) this.headers.response.push('Content-Type');\n      }\n    }\n\n    return this.headers;\n  }\n\n  /**\n   * Determine if the operation has an operation present in its schema. Note that if one is present\n   * in the schema but is an empty string then this will return false.\n   *\n   */\n  hasOperationId(): boolean {\n    return Boolean('operationId' in this.schema && this.schema.operationId.length);\n  }\n\n  /**\n   * Get an `operationId` for this operation. If one is not present (it's not required by the spec!)\n   * a hash of the path and method will be returned instead.\n   *\n   */\n  getOperationId(opts?: {\n    /**\n     * Generate a JS method-friendly operation ID when one isn't present.\n     */\n    camelCase: boolean;\n  }): string {\n    function sanitize(id: string) {\n      // We aren't sanitizing underscores here by default in order to preserve operation IDs that\n      // were already generated with this method in the past.\n      return id\n        .replace(opts?.camelCase ? /[^a-zA-Z0-9_]/g : /[^a-zA-Z0-9]/g, '-') // Remove weird characters\n        .replace(/--+/g, '-') // Remove double --'s\n        .replace(/^-|-$/g, ''); // Don't start or end with -\n    }\n\n    let operationId;\n    if (this.hasOperationId()) {\n      operationId = this.schema.operationId;\n    } else {\n      operationId = sanitize(this.path).toLowerCase();\n    }\n\n    const method = this.method.toLowerCase();\n    if (opts?.camelCase) {\n      operationId = operationId.replace(/[^a-zA-Z0-9_]+(.)/g, (_, chr) => chr.toUpperCase());\n      if (this.hasOperationId()) {\n        operationId = sanitize(operationId);\n      }\n\n      // Never start with a number.\n      operationId = operationId.replace(/^[0-9]/g, match => `_${match}`);\n\n      // Ensure that the first character of an `operationId` is always lowercase.\n      operationId = operationId.charAt(0).toLowerCase() + operationId.slice(1);\n\n      // If the generated `operationId` already starts with the method (eg. `getPets`) we don't want\n      // to double it up into `getGetPets`.\n      if (operationId.startsWith(method)) {\n        return operationId;\n      }\n\n      // If this operation already has an `operationId` and we just cleaned it up then we shouldn't\n      // prefix it with an HTTP method.\n      if (this.hasOperationId()) {\n        return operationId;\n      }\n\n      // Because we're merging the `operationId` into an HTTP method we need to reset the first\n      // character of it back to lowercase so end up with `getBuster`, not `getbuster`.\n      operationId = operationId.charAt(0).toUpperCase() + operationId.slice(1);\n      return `${method}${operationId}`;\n    } else if (this.hasOperationId()) {\n      return operationId;\n    }\n\n    return `${method}_${operationId}`;\n  }\n\n  /**\n   * Return an array of all tags, and their metadata, that exist on this operation.\n   *\n   */\n  getTags(): RMOAS.TagObject[] {\n    if (!('tags' in this.schema)) {\n      return [];\n    }\n\n    const oasTagMap: Map<string, RMOAS.TagObject> = new Map();\n    if ('tags' in this.api) {\n      this.api.tags.forEach((tag: RMOAS.TagObject) => {\n        oasTagMap.set(tag.name, tag);\n      });\n    }\n\n    const oasTags = Object.fromEntries(oasTagMap);\n\n    const tags: RMOAS.TagObject[] = [];\n    if (Array.isArray(this.schema.tags)) {\n      this.schema.tags.forEach(tag => {\n        if (tag in oasTags) {\n          tags.push(oasTags[tag]);\n        } else {\n          tags.push({\n            name: tag,\n          });\n        }\n      });\n    }\n\n    return tags;\n  }\n\n  /**\n   * Return is the operation is flagged as `deprecated` or not.\n   *\n   */\n  isDeprecated(): boolean {\n    return 'deprecated' in this.schema ? this.schema.deprecated : false;\n  }\n\n  /**\n   * Determine if the operation has any (non-request body) parameters.\n   *\n   */\n  hasParameters() {\n    return !!this.getParameters().length;\n  }\n\n  /**\n   * Return the parameters (non-request body) on the operation.\n   *\n   */\n  getParameters(): RMOAS.ParameterObject[] {\n    let parameters = (this.schema?.parameters || []) as RMOAS.ParameterObject[];\n    const commonParams = (this.api?.paths?.[this.path]?.parameters || []) as RMOAS.ParameterObject[];\n    if (commonParams.length) {\n      parameters = parameters.concat(dedupeCommonParameters(parameters, commonParams) || []);\n    }\n\n    return parameters;\n  }\n\n  /**\n   * Determine if this operation has any required parameters.\n   *\n   */\n  hasRequiredParameters() {\n    return this.getParameters().some(param => 'required' in param && param.required);\n  }\n\n  /**\n   * Convert the operation into an array of JSON Schema schemas for each available type of\n   * parameter available on the operation.\n   *\n   */\n  getParametersAsJSONSchema(opts: getParametersAsJSONSchemaOptions = {}) {\n    return getParametersAsJSONSchema(this, this.api, {\n      includeDiscriminatorMappingRefs: true,\n      transformer: (s: RMOAS.SchemaObject) => s,\n      ...opts,\n    });\n  }\n\n  /**\n   * Get a single response for this status code, formatted as JSON schema.\n   *\n   * @param statusCode Status code to pull a JSON Schema response for.\n   */\n  getResponseAsJSONSchema(\n    statusCode: string | number,\n    opts: {\n      /**\n       * If you wish to include discriminator mapping `$ref` components alongside your\n       * `discriminator` in schemas. Defaults to `true`.\n       */\n      includeDiscriminatorMappingRefs?: boolean;\n\n      /**\n       * With a transformer you can transform any data within a given schema, like say if you want\n       * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable\n       * name, just make sure to return your transformed schema.\n       */\n      transformer?: (schema: RMOAS.SchemaObject) => RMOAS.SchemaObject;\n    } = {},\n  ) {\n    return getResponseAsJSONSchema(this, this.api, statusCode, {\n      includeDiscriminatorMappingRefs: true,\n      transformer: (s: RMOAS.SchemaObject) => s,\n      ...opts,\n    });\n  }\n\n  /**\n   * Get an array of all valid response status codes for this operation.\n   *\n   */\n  getResponseStatusCodes(): string[] {\n    return this.schema.responses ? Object.keys(this.schema.responses) : [];\n  }\n\n  /**\n   * Determine if the operation has any request bodies.\n   *\n   */\n  hasRequestBody(): boolean {\n    return !!this.schema.requestBody;\n  }\n\n  /**\n   * Retrieve the list of all available media types that the operations request body can accept.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#mediaTypeObject}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#mediaTypeObject}\n   */\n  getRequestBodyMediaTypes() {\n    if (!this.hasRequestBody()) {\n      return [];\n    }\n\n    const requestBody = this.schema.requestBody;\n    if (RMOAS.isRef(requestBody)) {\n      // If the request body is still a `$ref` pointer we should return false because this library\n      // assumes that you've run dereferencing beforehand.\n      return [];\n    }\n\n    return Object.keys(requestBody.content);\n  }\n\n  /**\n   * Determine if this operation has a required request body.\n   *\n   */\n  hasRequiredRequestBody() {\n    if (!this.hasRequestBody()) {\n      return false;\n    }\n\n    const requestBody = this.schema.requestBody;\n    if (RMOAS.isRef(requestBody)) {\n      return false;\n    }\n\n    if (requestBody.required) {\n      return true;\n    }\n\n    // The OpenAPI spec isn't clear on the differentiation between schema `required` and\n    // `requestBody.required` because you can have required top-level schema properties but a\n    // non-required requestBody that negates each other.\n    //\n    // To kind of work ourselves around this and present a better QOL for this accessor, if at this\n    // final point where we don't have a required request body, but the underlying Media Type Object\n    // schema says that it has required properties then we should ultimately recognize that this\n    // request body is required -- even as the request body description says otherwise.\n    return !!this.getParametersAsJSONSchema()\n      .filter(js => ['body', 'formData'].includes(js.type))\n      .find(js => js.schema && Array.isArray(js.schema.required) && js.schema.required.length);\n  }\n\n  /**\n   * Retrieve a specific request body content schema off this operation.\n   *\n   * If no media type is supplied this will return either the first available JSON-like request\n   * body, or the first available if there are no JSON-like media types present. When this return\n   * comes back it's in the form of an array with the first key being the selected media type,\n   * followed by the media type object in question.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#mediaTypeObject}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#mediaTypeObject}\n   * @param mediaType Specific request body media type to retrieve if present.\n   */\n  getRequestBody(mediaType?: string): false | RMOAS.MediaTypeObject | [string, RMOAS.MediaTypeObject, ...string[]] {\n    if (!this.hasRequestBody()) {\n      return false;\n    }\n\n    const requestBody = this.schema.requestBody;\n    if (RMOAS.isRef(requestBody)) {\n      // If the request body is still a `$ref` pointer we should return false because this library\n      // assumes that you've run dereferencing beforehand.\n      return false;\n    }\n\n    if (mediaType) {\n      if (!(mediaType in requestBody.content)) {\n        return false;\n      }\n\n      return requestBody.content[mediaType];\n    }\n\n    // Since no media type was supplied we need to find either the first JSON-like media type that\n    // we've got, or the first available of anything else if no JSON-like media types are present.\n    let availableMediaType: string;\n    const mediaTypes = this.getRequestBodyMediaTypes();\n    mediaTypes.forEach((mt: string) => {\n      if (!availableMediaType && matchesMimeType.json(mt)) {\n        availableMediaType = mt;\n      }\n    });\n\n    if (!availableMediaType) {\n      mediaTypes.forEach((mt: string) => {\n        if (!availableMediaType) {\n          availableMediaType = mt;\n        }\n      });\n    }\n\n    if (availableMediaType) {\n      return [\n        availableMediaType,\n        requestBody.content[availableMediaType],\n        ...(requestBody.description ? [requestBody.description] : []),\n      ];\n    }\n\n    return false;\n  }\n\n  /**\n   * Retrieve an array of request body examples that this operation has.\n   *\n   */\n  getRequestBodyExamples(): RequestBodyExamples {\n    if (this.requestBodyExamples) {\n      return this.requestBodyExamples;\n    }\n\n    this.requestBodyExamples = getRequestBodyExamples(this.schema);\n    return this.requestBodyExamples;\n  }\n\n  /**\n   * Return a specific response out of the operation by a given HTTP status code.\n   *\n   * @param statusCode Status code to pull a response object for.\n   */\n  getResponseByStatusCode(statusCode: string | number): boolean | RMOAS.ResponseObject {\n    if (!this.schema.responses) {\n      return false;\n    }\n\n    if (typeof this.schema.responses[statusCode] === 'undefined') {\n      return false;\n    }\n\n    const response = this.schema.responses[statusCode];\n\n    if (RMOAS.isRef(response)) {\n      return false;\n    }\n\n    // Remove the reference from the type, because it will already be dereferenced.\n    return response;\n  }\n\n  /**\n   * Retrieve an array of response examples that this operation has.\n   *\n   */\n  getResponseExamples(): ResponseExamples {\n    if (this.responseExamples) {\n      return this.responseExamples;\n    }\n\n    // @todo Remove this `as` once we convert getResponseExamples\n    this.responseExamples = getResponseExamples(this.schema) as ResponseExamples;\n    return this.responseExamples;\n  }\n\n  /**\n   * Determine if the operation has callbacks.\n   *\n   */\n  hasCallbacks(): boolean {\n    return !!this.schema.callbacks;\n  }\n\n  /**\n   * Retrieve a specific callback.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callbackObject}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}\n   * @param identifier Callback identifier to look for.\n   * @param expression Callback expression to look for.\n   * @param method HTTP Method on the callback to look for.\n   */\n  getCallback(identifier: string, expression: string, method: RMOAS.HttpMethods): false | Callback {\n    if (!this.schema.callbacks) return false;\n\n    // The usage of `as` in the below is to remove the possibility of a ref type, since we've\n    // dereferenced.\n    const callback = this.schema.callbacks[identifier]\n      ? (((this.schema.callbacks as Record<string, RMOAS.CallbackObject>)[identifier] as RMOAS.CallbackObject)[\n          expression\n        ] as RMOAS.PathItemObject)\n      : false;\n\n    if (!callback || !callback[method]) return false;\n    return new Callback(this.api, expression, method, callback[method], identifier, callback);\n  }\n\n  /**\n   * Retrieve an array of operations created from each callback.\n   *\n   */\n  getCallbacks(): false | (false | Callback)[] {\n    const callbackOperations: (false | Callback)[] = [];\n    if (!this.hasCallbacks()) return false;\n\n    Object.keys(this.schema.callbacks).forEach(callback => {\n      Object.keys(this.schema.callbacks[callback]).forEach(expression => {\n        const cb = this.schema.callbacks[callback];\n\n        if (!RMOAS.isRef(cb)) {\n          const exp = cb[expression];\n\n          if (!RMOAS.isRef(exp)) {\n            Object.keys(exp).forEach((method: RMOAS.HttpMethods) => {\n              if (!supportedMethods.has(method)) return;\n\n              callbackOperations.push(this.getCallback(callback, expression, method));\n            });\n          }\n        }\n      });\n    });\n\n    return callbackOperations;\n  }\n\n  /**\n   * Retrieve an array of callback examples that this operation has.\n   *\n   */\n  getCallbackExamples(): CallbackExamples {\n    if (this.callbackExamples) {\n      return this.callbackExamples;\n    }\n\n    this.callbackExamples = getCallbackExamples(this.schema);\n    return this.callbackExamples;\n  }\n\n  /**\n   * Determine if a given a custom specification extension exists within the operation.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}\n   * @param extension Specification extension to lookup.\n   */\n  hasExtension(extension: string) {\n    return Boolean(this.schema && extension in this.schema);\n  }\n\n  /**\n   * Retrieve a custom specification extension off of the operation.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}\n   * @param extension Specification extension to lookup.\n   */\n  getExtension(extension: string) {\n    return this.schema?.[extension];\n  }\n}\n\nexport class Callback extends Operation {\n  /**\n   * The identifier that this callback is set to.\n   */\n  identifier: string;\n\n  /**\n   * The parent path item object that this Callback exists within.\n   */\n  parentSchema: RMOAS.PathItemObject;\n\n  constructor(\n    oas: RMOAS.OASDocument,\n    path: string,\n    method: RMOAS.HttpMethods,\n    operation: RMOAS.OperationObject,\n    identifier: string,\n    parentPathItem: RMOAS.PathItemObject,\n  ) {\n    super(oas, path, method, operation);\n\n    this.identifier = identifier;\n    this.parentSchema = parentPathItem;\n  }\n\n  /**\n   * Return the primary identifier for this callback.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callback-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}\n   */\n  getIdentifier(): string {\n    return this.identifier;\n  }\n\n  getSummary(): string {\n    if (this.schema?.summary && typeof this.schema.summary === 'string') {\n      return this.schema.summary;\n    } else if (this.parentSchema.summary && typeof this.parentSchema.summary === 'string') {\n      return this.parentSchema.summary;\n    }\n\n    return undefined;\n  }\n\n  getDescription(): string {\n    if (this.schema?.description && typeof this.schema.description === 'string') {\n      return this.schema.description;\n    } else if (this.parentSchema.description && typeof this.parentSchema.description === 'string') {\n      return this.parentSchema.description;\n    }\n\n    return undefined;\n  }\n\n  getParameters(): RMOAS.ParameterObject[] {\n    let parameters = (this.schema?.parameters || []) as RMOAS.ParameterObject[];\n    const commonParams = (this.parentSchema.parameters || []) as RMOAS.ParameterObject[];\n    if (commonParams.length) {\n      parameters = parameters.concat(dedupeCommonParameters(parameters, commonParams) || []);\n    }\n\n    return parameters;\n  }\n}\n\nexport class Webhook extends Operation {\n  /**\n   * OpenAPI API Definition that this webhook originated from.\n   */\n  declare api: RMOAS.OAS31Document;\n\n  getSummary(): string {\n    if (this.schema?.summary && typeof this.schema.summary === 'string') {\n      return this.schema.summary;\n    } else if (this.api.webhooks[this.path].summary && typeof this.api.webhooks[this.path].summary === 'string') {\n      return this.api.webhooks[this.path].summary;\n    }\n\n    return undefined;\n  }\n\n  getDescription(): string {\n    if (this.schema?.description && typeof this.schema.description === 'string') {\n      return this.schema.description;\n    } else if (\n      this.api.webhooks[this.path].description &&\n      typeof this.api.webhooks[this.path].description === 'string'\n    ) {\n      return this.api.webhooks[this.path].description;\n    }\n\n    return undefined;\n  }\n}\n"]}