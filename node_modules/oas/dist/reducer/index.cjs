"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkW6GBV2JTcjs = require('../chunk-W6GBV2JT.cjs');

// src/reducer/index.ts
var _jsonpointer = require('jsonpointer'); var _jsonpointer2 = _interopRequireDefault(_jsonpointer);
var _utils = require('oas-normalize/lib/utils');
function getUsedRefs(schema) {
  return _chunkW6GBV2JTcjs.query.call(void 0, ["$..['$ref']"], schema);
}
function accumulateUsedRefs(schema, $refs, $ref) {
  let $refSchema;
  if (typeof $ref === "string")
    $refSchema = _jsonpointer2.default.get(schema, $ref.substring(1));
  if ($refSchema === void 0) {
    return;
  }
  getUsedRefs($refSchema).forEach(({ value: currRef }) => {
    if ($refs.has(currRef)) {
      return;
    }
    $refs.add(currRef);
    accumulateUsedRefs(schema, $refs, currRef);
  });
}
function reducer(definition, opts = {}) {
  const reduceTags = "tags" in opts ? opts.tags.map((tag) => tag.toLowerCase()) : [];
  const reducePaths = "paths" in opts ? Object.entries(opts.paths).reduce((acc, [key, value]) => {
    const newKey = key.toLowerCase();
    const newValue = Array.isArray(value) ? value.map((v) => v.toLowerCase()) : value.toLowerCase();
    acc[newKey] = newValue;
    return acc;
  }, {}) : {};
  const $refs = /* @__PURE__ */ new Set();
  const usedTags = /* @__PURE__ */ new Set();
  if (_utils.getAPIDefinitionType.call(void 0, definition) !== "openapi") {
    throw new Error("Sorry, only OpenAPI definitions are supported.");
  }
  const reduced = JSON.parse(JSON.stringify(definition));
  if ("security" in reduced) {
    Object.values(reduced.security).forEach((sec) => {
      Object.keys(sec).forEach((scheme) => {
        $refs.add(`#/components/securitySchemes/${scheme}`);
      });
    });
  }
  if ("paths" in reduced) {
    Object.keys(reduced.paths).forEach((path) => {
      const pathLC = path.toLowerCase();
      if (Object.keys(reducePaths).length) {
        if (!(pathLC in reducePaths)) {
          delete reduced.paths[path];
          return;
        }
      }
      Object.keys(reduced.paths[path]).forEach((method) => {
        if (method !== "parameters") {
          if (Object.keys(reducePaths).length) {
            if (reducePaths[pathLC] !== "*" && Array.isArray(reducePaths[pathLC]) && !reducePaths[pathLC].includes(method)) {
              delete reduced.paths[path][method];
              return;
            }
          }
        }
        const operation = reduced.paths[path][method];
        if (reduceTags.length) {
          if (!("tags" in operation)) {
            delete reduced.paths[path][method];
            return;
          } else if (!operation.tags.filter((tag) => reduceTags.includes(tag.toLowerCase())).length) {
            delete reduced.paths[path][method];
            return;
          }
        }
        if ("tags" in operation) {
          operation.tags.forEach((tag) => {
            usedTags.add(tag);
          });
        }
        getUsedRefs(operation).forEach(({ value: ref }) => {
          $refs.add(ref);
        });
        if ("security" in operation) {
          Object.values(operation.security).forEach((sec) => {
            Object.keys(sec).forEach((scheme) => {
              $refs.add(`#/components/securitySchemes/${scheme}`);
            });
          });
        }
      });
      if (!Object.keys(reduced.paths[path]).length) {
        delete reduced.paths[path];
      }
    });
    if (!Object.keys(reduced.paths).length) {
      throw new Error("All paths in the API definition were removed. Did you supply the right path name to reduce by?");
    }
  }
  $refs.forEach(($ref) => accumulateUsedRefs(reduced, $refs, $ref));
  if ("components" in reduced) {
    Object.keys(reduced.components).forEach((componentType) => {
      Object.keys(reduced.components[componentType]).forEach((component) => {
        if (!$refs.has(`#/components/${componentType}/${component}`)) {
          delete reduced.components[componentType][component];
        }
      });
      if (!Object.keys(reduced.components[componentType]).length) {
        delete reduced.components[componentType];
      }
    });
    if (!Object.keys(reduced.components).length) {
      delete reduced.components;
    }
  }
  if ("tags" in reduced) {
    reduced.tags.forEach((tag, k) => {
      if (!usedTags.has(tag.name)) {
        delete reduced.tags[k];
      }
    });
    reduced.tags = reduced.tags.filter(Boolean);
    if (!reduced.tags.length) {
      delete reduced.tags;
    }
  }
  return reduced;
}


exports.default = reducer;

module.exports = exports.default//# sourceMappingURL=index.cjs.map